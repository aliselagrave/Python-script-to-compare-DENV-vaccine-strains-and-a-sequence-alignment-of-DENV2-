##########################  DESCRIPTION ###############################

# Ce programme permet d'identifier les mutations protéiques d'un ensemble de souches
# par rapport à une souche de référence, et de les mettre en évidence dans un fichier
# excel.

# Le data contenant les souches doit être dans un fichier de type .fa (FASTA)

###############  INSTALLATION DES MODULES #################

#installer BioPython dans le shell : pip install biopython
#installer pandas dans le shell : pip install pandas openpyxl
#installer Jinja2 dans le shell : pip install jinja2

import pandas as pd
import numpy as np
from Bio import SeqIO
from pandas.core.frame import dataclasses_to_dicts

#librairie biopython

#### OUVERTURE DES FICHIERS FASTA  ####

Fasta_file = 'Dengvaxia_alignement_input.fasta'

###########################  INITIALISATION #########################

#### SOUCHE DE REFERENCE  ####

ref_souche = list(SeqIO.parse(Fasta_file,
                              "fasta"))[0]  # SeqRecord de la souche
ref_souche_seq = ref_souche.seq  # séquence de nucléotides de référence
ref_souche_AA = ref_souche_seq.translate()  # séquence protéique de référence

REFERENCE = []  # séquence de référence sous forme de liste

for index, letter in enumerate(
    ref_souche_AA
):  # transformation séquence de référence en liste de nucléotides
  codon_ref = ref_souche_seq[index * 3:index * 3 + 3]
  REFERENCE.append(codon_ref + '     ' + letter)

REFERENCE.append(' ')
REFERENCE.append('NOMBRE DE MUTATIONS')

####  NUMEROTATION DES NUCLEOTIDES  ####

NUM = []
num = 1
longueur = len(ref_souche_seq)

while num <= longueur:
  NUM.append(str(num) + '-' + str(num + 2))
  num = num + 3

NUM.append(' ')
NUM.append(' ')

####  CREATION DATA  ####

data = {'REFERENCE': REFERENCE, 'AN POSITION': NUM}
df = pd.DataFrame(data)  # création dataframe

############ ANALYSE DES SEQUENCES#################

####  IDENTIFICATION DIFFERENCES PAR RAPPORT A LA SOUCHE REFERENCE  ####

for seq_record in SeqIO.parse(
    Fasta_file, "fasta"):  # extraction de chaque souche du fichier fasta

  i = 0  #Décompte nombre de mutations pour chaque souche

  name = seq_record.id  #nom souche
  sequence_mutations = []  #liste des mutations

  seq = seq_record.seq  #séquence nucléotidique analysée
  seq_AA = seq.translate()  #séquence protéique correspondante

  for index, letter in enumerate(seq_AA):
    if letter != ref_souche_AA[
        index]:  #identification des différences par rapport à la souche de référence
      i += 1
      codon = seq[index * 3:index * 3 + 3]
      sequence_mutations.append(codon + '    ' + letter)
    else:
      sequence_mutations.append(' ')

  sequence_mutations.append(' ')
  sequence_mutations.append(str(i))

  df[name] = sequence_mutations  #ajout du data au dataframe

####  SELECTION DES MUTATIONS UNIQUEMENT DANS LE DATA  ####

# Suppression des lignes contenant uniquement des espaces dans les cellules des codons
df_filtered = df[~df.iloc[:, 2:].
                 apply(lambda row: all(cell == ' ' for cell in row), axis=1)]

####  DECOMPTE NOMBRE MUTATIONS PAR SECTION  DE LA SEQUENCE  ####

SECTIONS = [343, 840, 2319, 3375, 4029, 4419, 6276, 6657, 6726, 7470,
            10140]  #limite des positions par section
NOMS_SECTIONS = [
    'AncC', 'prM', 'E', 'NS1', 'NS2A', 'NS2B', 'NS3', 'NS4A', '2K', 'NS4B',
    'NS5'
]  #noms des sections
NOMBRE_MUTATIONS = []

for a in range(len(SECTIONS)):
  count = 0
  for i in df_filtered.index:
    b = 1 if (a - 1) < 0 else SECTIONS[a - 1]

    if (i + 1) * 3 + 3 <= b:
      continue
    if (i + 1) * 3 + 3 <= SECTIONS[a]:
      count += 1
  NOMBRE_MUTATIONS.append(count)

for nom in NOMS_SECTIONS:
  print('Mutations', nom, ' : ', NOMBRE_MUTATIONS[NOMS_SECTIONS.index(nom)])

print('Mutations totales : ', sum(NOMBRE_MUTATIONS))

##########################  CREATION EXCEL  ######################

####  Fonction pour colorier les cellules  ####


def highlight_mutations(val):
  '''
    Colorie les cellules en fonction de la mutation du codon.
    '''
  if val.endswith(' '):
    return 'background-color: white'
  elif val.endswith('A'):
    return 'background-color: #FF0000'  # rouge
  elif val.endswith('D'):
    return 'background-color: #FFA500'  # orange
  elif val.endswith('E'):
    return 'background-color: #FFFF00'  # jaune
  elif val.endswith('G'):
    return 'background-color: #A52A2A'  # marron
  elif val.endswith('H'):
    return 'background-color: #FFD700'  # or
  elif val.endswith('I'):
    return 'background-color: #ADD8E6'  # bleu clair
  elif val.endswith('L'):
    return 'background-color: #E6E6FA'  # lavande
  elif val.endswith('M'):
    return 'background-color: #0000FF'  # bleu
  elif val.endswith('N'):
    return 'background-color: #00FF00'  # vert
  elif val.endswith('Q'):
    return 'background-color: #D2691E'  # marron
  elif val.endswith('S'):
    return 'background-color: #00FFFF'  # cyan
  elif val.endswith('T'):
    return 'background-color: #FF69B4'  # rose
  elif val.endswith('V'):
    return 'background-color: #90EE90'  # vert clair
  elif val.endswith('Y'):
    return 'background-color: #8B0000'  # rouge foncé
  elif val.endswith('K'):
    return 'background-color: #FFC0CB'  # rose clair'
  elif val.endswith('P'):
    return 'background-color: #FF1493'  # magenta'
  elif val.endswith('R'):
    return 'background-color: #FF4500'  # orange foncé'
  else:
    return ''  # pour les autres cas non spécifiés


####  Formatage du style couleur au DataFrame  ####
styled_df = df_filtered.style.map(highlight_mutations)

####  Export Excel intermédiaire   ####
styled_df.to_excel('DENV2_PROT_FILTERED.xlsx',engine='openpyxl',index=False)

#####  Vérification export  ####
#print("Le DataFrame a été exporté avec succès dans le fichier 'DENV2_PROT_FILTERED.xlsx'")

### recuperation des index ###
Nom_colonnes = df_filtered.columns.values
Nom_colonnes = np.insert(Nom_colonnes, 0, "AA POSITON")

########## Numerotation sur sequence codante en AA/region ########
# Charger le fichier Excel
file_path = 'DENV2_PROT_FILTERED.xlsx' 
df = pd.read_excel(file_path)

#### Transposer le DataFrame ####
df_transpose = df.T 

#### Changement des positions en AA ####
Position_AN = df_transpose.iloc[1].values
Position_separe = []
for element in Position_AN:
  Position_separe.extend(element.split('-'))

Position_separe.pop()
Position_separe_num = [
    float(element) if '.' in element else int(element)
    for element in Position_separe
]
Position_AA = []
for val in Position_separe_num:
  nouvelles_valeurs = (int(val) / 3) + 1
  Position_AA.append(nouvelles_valeurs)
Position_AA_conserve = [
  Position_AA[i] for i in range(len(Position_AA))
    if i % 2 != 0
]

#### Recuperation des positions dans le tableau des differentes régions ####
position_dep = next((index for index, valeur in enumerate(Position_AA_conserve) if valeur > 115), None)
position_mid = next((index for index, valeur in enumerate(Position_AA_conserve) if valeur > 281), None)
position_fin = next((index for index, valeur in enumerate(Position_AA_conserve) if valeur > 775), None)
nombre_colonnes = df_transpose.shape[1]

#### Ajout d'une valeur nul pour que les vecteurs/tableau soit de la meme taille ####
Position_AA_conserve.append("")

#### Ajout des positions en AA dans le tableau et invertion des lignes pour que ce soit dans le bon ordre ####
nouvelle_ligne = pd.DataFrame([Position_AA_conserve], columns=df_transpose.columns)
data = pd.concat([nouvelle_ligne, df_transpose], ignore_index=True)
data.index = Nom_colonnes
index_list = data.index.tolist()  # Convertir les noms d'index en liste
index_list[1], index_list[2] = index_list[2], index_list[
    1]  # Intervertir les deux premiers
data.index = index_list  # Réaffecter les noms modifiés au DataFrame
data.iloc[[1, 2]] = data.iloc[[2, 1]].values

#### Sauvegarde du fichier Excel avec toute les regions ####
data.to_excel('tableau avec toute les regions.xlsx', index=True)


colonnes_a_garder = data.columns[position_dep:(position_fin)].tolist() + [data.columns[nombre_colonnes-1]]
vecteur = ["prM"] * (position_mid-position_dep) + ["Envelope"] * (position_fin-position_mid) + ["Nombre de mutation"]

data_epure = data[colonnes_a_garder]
data_epure.columns = vecteur

##### changement des positions pour que le debut de la regions soit le debut des position en AA ##### 
data_epure.iloc[0, :position_mid-position_dep] = data_epure.iloc[0, :position_mid-position_dep] - 115
data_epure.iloc[0, (position_mid-position_dep):(position_fin-position_dep)] = data_epure.iloc[0, (position_mid-position_dep):(position_fin-position_dep)] - 281

data_epure.to_excel('tableau avec prM et envelope.xlsx', index=True)